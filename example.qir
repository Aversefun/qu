@@quver("0.0.1")
@@runtime_checks(array_bounds, underflow)
@@check_violated(libc_exit(1))

@extern(C, "exit")
fn libc_exit(i32) -> !; // function returning is undefined behavior

@extern(C, "printf")
fn libc_printf(c_str, ...) -> i32; // user assumes responsibility of ensuring the correct number of arguments

@repr(C)
struct Test {
    $field0: u8,
    $field1: u16,
    $field2: f32,
    $length: uptr,
    $field3: *[Test; $length.0],
}

@export(C, "main")
fn main($argc: uptr, $argv: *[c_str; $argc.0]) -> ! &entry {
    $v0: i32;
    $m0: mem i32; // a value in memory (typed uptr)
    $s0: Test;
    &entry {
        $v0.1 = 0;
        $m0._ = 1; // very obvious that it's a memory address
        $s0.0.field0 = 0; // default value of undef
        $s0.0.field1 = 0; // can only set each field once per version
        $s0.0.field2 = 0.0;
        $s0.0.length = 0;
        $s0.0.field3 = &_; // special address that is guarenteed to be non-null but shouldn't be dereferenced
        x86_64:intel [ ; Will be skipped over on other architectures.
            ; Inline assembly
            add eax, 8
        ] (
            $v0.1:eax,
            eax:$v0.2,
//          ebx:$_, // Specifies clobbered registers.
            // Rust's
        // https://doc.rust-lang.org/reference/inline-assembly.html#r-asm.options.supported-options
            // tells about options. Check back here for actually supported ones though.
            _opt:noflags, // _opt specifies parameters for the compiler. noflags means that the flags
                          // aren't touched.
//          _opt:noreturn,
            _opt:pure,    // Pure means that it is completely deterministic and only depends on direct
                          // inputs. See the Rust reference.
            _opt:nomem,
//          _opt:readonly,
            _opt:nostack,
        );
        x86_64:intel [ ; Inline assembly block without options
            ; Inline assembly
            nop
        ] ();
        $v0.3 = (phi $v0.1, $v0.2);
        $v1: u32;
        $v1.0 = self.add($argc, 50);
        $v1.1 = (% $v1.0, 50);
        $v1.2 = (- 10, $v1.1);
        //$v1.3 = !$v1.2; // Bitwise inversion
        _ = libc_printf(c"argc=%d", $v1.2);
        no_return_function();
        $v2: uptr;
        $v2.0 = 11;
        _ = libc_printf(c"v2=%d", $v2.0);
        (cmpbr $v1.2, eq, 9, &true, &end);
    };
    &true {
        _ = libc_printf(c"one argument passed");
        (jmp &end);
    };
    &end {
        _ = libc_printf(c"v0=%d on x86_64 v0 should be 8 and on others should be 0", $v0.3);
        libc_exit(0);
    };
}

fn no_return_function() {
    _ = libc_printf(c"this is from no_return_function");
    (ret);
}

@hint(inline:always)
fn add($a: u32, $b: u32) -> u32 {
    $c: u32;
    $c.0 = (+ $a, $b);
    (ret $c.0);
}